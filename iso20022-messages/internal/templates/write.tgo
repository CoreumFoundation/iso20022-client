// Code generated by GoComply XSD2Go for iso20022; DO NOT EDIT.
{{- $targetNS := .TargetNamespace }}
{{- $nsPrefix := .Xmlns.PrefixByUri .TargetNamespace }}
{{- $allXmlns := .Xmlns }}
// Models for {{ $targetNS }}{{ if ne $nsPrefix "" }} with prefix '{{ $nsPrefix }}'{{ end }}
package {{ .GoPackageName }}

import (
	"fmt"
	"github.com/CoreumFoundation/iso20022-client/iso20022-messages/pkg/iso"
	{{- range .GoImportsNeeded }}
		"{{ . }}"
	{{- end }}
)

{{ range .ExportableElements }}
	{{ $elemLen := len .Elements }}{{ if and (gt $elemLen 0) (ne $nsPrefix "") }}
		// MarshalXML is a custom marshaller that allows us to manipulate the XML tag in order to use the proper namespace prefix
		func (v {{ .GoName }}) MarshalXML(e *xml.Encoder, start xml.StartElement) error {
			{{- if .Attributes }}
				var attr = []xml.Attr{}
				{{- range .Attributes }}
				{{ if eq .Use "optional" }}if v.{{ .GoName }} != nil { {{ end }}
					attr = append(attr, xml.Attr{Name: xml.Name{Local: "{{ .XmlName }}"}, Value: {{ if eq .Use "optional" }}*{{ end }}v.{{ .GoName }}},)
				{{ if eq .Use "optional" }} } {{ end }}
				{{- end }}
				e.EncodeToken(xml.StartElement{
					Name: xml.Name{Local: start.Name.Local},
					Attr: attr,
				})
			{{- else }}
				e.EncodeToken(xml.StartElement{Name: xml.Name{Local: start.Name.Local}})
			{{- end }}
			{{- range .Elements }}
				e.EncodeElement(v.{{ .GoFieldName }}, xml.StartElement{Name: xml.Name{Local: "{{ $nsPrefix }}:{{ .Name }}"}})
			{{- end }}
			e.EncodeToken(xml.EndElement{Name: xml.Name{Local: start.Name.Local}})
			return nil
		}
	{{ end }}

	{{ if eq .GoName "Message" }}
        // Element interface for ISO 20022
        type Iso20022Message interface {
            // Validate will be process validation check of document
            Validate() error
        }
        type ConstructorFunc func() Iso20022Message
        type ConstructorWithUrn struct {
            Constructor ConstructorFunc
            Urn string
        }

        func GetMessageConstructors() (map[string]ConstructorFunc, map[string][]ConstructorWithUrn) {
            var urn string
            var list []ConstructorWithUrn
            var exists bool
            urnMap := make(map[string]ConstructorFunc)
            messagesMap := make(map[string][]ConstructorWithUrn)
            {{- range .Elements }}
                {{- $l := len .GoForeignModule }}
                {{- $l1 := len (slice (printf "%*s" $l "") 16) }}
                {{- $l2 := len (slice (printf "%*s" $l "") 12) }}
                {{- $l3 := len (slice (printf "%*s" $l "") 11) }}
                {{- $l4 := len (slice (printf "%*s" $l "") 8) }}
                {{- $l41 := len (slice (printf "%*s" $l "") 7) }}
                {{- $l51 := len (slice (printf "%*s" $l "") 4) }}
                {{- $l5 := len (slice (printf "%*s" $l "") 3) }}
                {{- $l6 := len (slice (printf "%*s" $l "") 1) }}
                {{- $p1 := slice .GoForeignModule $l1 $l2 }}
                {{- $p2 := slice .GoForeignModule $l3 $l4 }}
                {{- $p3 := slice .GoForeignModule $l41 $l51 }}
                {{- $p4 := slice .GoForeignModule $l5 $l6 }}
                {{- $gfm := .GoForeignModule }}
                {{ if eq .GoTypeName "Document" }}
                    urn = "urn:iso:std:iso:20022:tech:xsd:{{ $p1 }}.{{ $p2 }}.{{ $p3 }}.{{ $p4 }}"
                    urnMap[urn] = func() Iso20022Message { return &{{ $gfm }}{{ (index .Elements 0).GoTypeName }}{} }
                    list, exists = messagesMap["{{ (index .Elements 0).GoName }}"]
                    if !exists {
                        list = make([]ConstructorWithUrn, 0)
                    }
                    list = append(list, ConstructorWithUrn{
                        Constructor: func() Iso20022Message { return &{{ $gfm }}{{ (index .Elements 0).GoTypeName }}{} },
                        Urn: urn,
                    })
                    messagesMap["{{ (index .Elements 0).GoName }}"] = list
                {{ else }}
                    urn = "urn:iso:std:iso:20022:tech:xsd:{{ $p1 }}.{{ $p2 }}.{{ $p3 }}.{{ $p4 }}"
                    urnMap[urn] = func() Iso20022Message { return &{{ $gfm }}{{ .GoTypeName }}{} }
                    list, exists = messagesMap["{{ .GoName }}"]
                    if !exists {
                        list = make([]ConstructorWithUrn, 0)
                    }
                    list = append(list, ConstructorWithUrn{
                        Constructor: func() Iso20022Message { return &{{ $gfm }}{{ .GoTypeName }}{} },
                        Urn: urn,
                    })
                    messagesMap["{{ .GoName }}"] = list
                {{ end }}
            {{- end }}
            return urnMap, messagesMap;
		}
	{{ end }}
{{ end }}

{{ range .ExportableComplexTypes }}
	{{ if eq .GoName "SignatureEnvelope" }}
		{{ template "SignatureEnvelope" . }}
	{{ else if eq .GoName "HdrAndData" }}
	{{ else if eq .GoName "HdrAndDataTCH" }}
	{{ else if eq .GoName "DocumentTCH" }}
	{{ else }}
		{{ $elemLen := len .Elements }}{{ if and (gt $elemLen 0) (ne $nsPrefix "") }}
			// MarshalXML is a custom marshaller that allows us to manipulate the XML tag in order to use the proper namespace prefix
			func (v {{ .GoName }}) MarshalXML(e *xml.Encoder, start xml.StartElement) error {
				{{- if .Attributes }}
					var attr = []xml.Attr{}
					{{- range .Attributes }}
					{{ if eq .Use "optional" }}if v.{{ .GoName }} != nil { {{ end }}
						attr = append(attr, xml.Attr{Name: xml.Name{Local: "{{ .XmlName }}"}, Value: {{ if eq .Use "optional" }}*{{ end }}v.{{ .GoName }}},)
					{{ if eq .Use "optional" }} } {{ end }}
					{{- end }}
					e.EncodeToken(xml.StartElement{
						Name: xml.Name{Local: start.Name.Local},
						Attr: attr,
					})
				{{- else }}
					e.EncodeToken(xml.StartElement{Name: xml.Name{Local: start.Name.Local}})
				{{- end }}
				{{- range .Elements }}
					e.EncodeElement(v.{{ .GoFieldName }}, xml.StartElement{Name: xml.Name{Local: "{{ $nsPrefix }}:{{ .Name }}"}})
				{{- end }}
				e.EncodeToken(xml.EndElement{Name: xml.Name{Local: start.Name.Local}})
				return nil
			}
		{{ end }}
	{{ end }}
{{ end }}

{{ range .ExportableSimpleTypes }}
	{{ if eq .GoName "ActiveCurrencyAndAmountSimpleType" }}
		{{ template "ActiveCurrencyAndAmountSimpleType" . }}
	{{ else if eq .GoName "ActiveOrHistoricCurrencyAndAmountSimpleType" }}
		{{ template "ActiveOrHistoricCurrencyAndAmountSimpleType" . }}
	{{ else if eq .GoName "ISODate" }}
	{{ else if eq .GoName "ISODateTime" }}
	{{ else if eq .GoName "ISONormalisedDateTime" }}
	{{ else if eq .GoName "Max20000Text" }}
	{{ end }}
{{ end }}

{{ define "ActiveCurrencyAndAmountSimpleType" }}
	func (a ActiveCurrencyAndAmountSimpleType) MarshalText() ([]byte, error) {
		return iso.Amount(a).MarshalText()
	}
{{ end }}

{{ define "ActiveOrHistoricCurrencyAndAmountSimpleType" }}
	func (a ActiveOrHistoricCurrencyAndAmountSimpleType) MarshalText() ([]byte, error) {
		return iso.Amount(a).MarshalText()
	}
{{ end }}

{{ define "SignatureEnvelope" }}
	// MarshalXML is a custom marshaller that allows us to manipulate the XML tag in order to use the proper namespace prefix
	func (v Sgntr) MarshalXML(e *xml.Encoder, start xml.StartElement) error {
		e.EncodeToken(xml.StartElement{Name: xml.Name{Local: start.Name.Local}})
		e.EncodeElement(v.Signature, xml.StartElement{Name: xml.Name{Local: "ds:Signature"}})
		e.EncodeToken(xml.EndElement{Name: xml.Name{Local: start.Name.Local}})
		return nil
	}
{{ end }}
